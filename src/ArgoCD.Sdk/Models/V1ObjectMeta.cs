// <auto-generated/>
#pragma warning disable CS0618
using Microsoft.Kiota.Abstractions.Extensions;
using Microsoft.Kiota.Abstractions.Serialization;
using System.Collections.Generic;
using System.IO;
using System;
namespace ArgoCD.Sdk.Models
{
    /// <summary>
    /// ObjectMeta is metadata that all persisted resources must have, which includes all objectsusers must create.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
    public partial class V1ObjectMeta : IAdditionalDataHolder, IParsable
    {
        /// <summary>Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.</summary>
        public IDictionary<string, object> AdditionalData { get; set; }
        /// <summary>The annotations property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::ArgoCD.Sdk.Models.V1ObjectMeta_annotations? Annotations { get; set; }
#nullable restore
#else
        public global::ArgoCD.Sdk.Models.V1ObjectMeta_annotations Annotations { get; set; }
#endif
        /// <summary>Time is a wrapper around time.Time which supports correctmarshaling to YAML and JSON.  Wrappers are provided for manyof the factory methods that the time package offers.+protobuf.options.marshal=false+protobuf.as=Timestamp+protobuf.options.(gogoproto.goproto_stringer)=false</summary>
        public DateTimeOffset? CreationTimestamp { get; set; }
        /// <summary>The deletionGracePeriodSeconds property</summary>
        public long? DeletionGracePeriodSeconds { get; set; }
        /// <summary>Time is a wrapper around time.Time which supports correctmarshaling to YAML and JSON.  Wrappers are provided for manyof the factory methods that the time package offers.+protobuf.options.marshal=false+protobuf.as=Timestamp+protobuf.options.(gogoproto.goproto_stringer)=false</summary>
        public DateTimeOffset? DeletionTimestamp { get; set; }
        /// <summary>The finalizers property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<string>? Finalizers { get; set; }
#nullable restore
#else
        public List<string> Finalizers { get; set; }
#endif
        /// <summary>GenerateName is an optional prefix, used by the server, to generate a uniquename ONLY IF the Name field has not been provided.If this field is used, the name returned to the client will be differentthan the name passed. This value will also be combined with a unique suffix.The provided value has the same validation rules as the Name field,and may be truncated by the length of the suffix required to make the valueunique on the server.If this field is specified and the generated name exists, the server will return a 409.Applied only if Name is not specified.More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency+optional</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? GenerateName { get; set; }
#nullable restore
#else
        public string GenerateName { get; set; }
#endif
        /// <summary>The generation property</summary>
        public long? Generation { get; set; }
        /// <summary>The labels property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::ArgoCD.Sdk.Models.V1ObjectMeta_labels? Labels { get; set; }
#nullable restore
#else
        public global::ArgoCD.Sdk.Models.V1ObjectMeta_labels Labels { get; set; }
#endif
        /// <summary>ManagedFields maps workflow-id and version to the set of fieldsthat are managed by that workflow. This is mostly for internalhousekeeping, and users typically shouldn&apos;t need to set orunderstand this field. A workflow can be the user&apos;s name, acontroller&apos;s name, or the name of a specific apply path like&quot;ci-cd&quot;. The set of fields is always in the version that theworkflow used when modifying the object.+optional+listType=atomic</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<global::ArgoCD.Sdk.Models.V1ManagedFieldsEntry>? ManagedFields { get; set; }
#nullable restore
#else
        public List<global::ArgoCD.Sdk.Models.V1ManagedFieldsEntry> ManagedFields { get; set; }
#endif
        /// <summary>The name property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? Name { get; set; }
#nullable restore
#else
        public string Name { get; set; }
#endif
        /// <summary>Namespace defines the space within which each name must be unique. An empty namespace isequivalent to the &quot;default&quot; namespace, but &quot;default&quot; is the canonical representation.Not all objects are required to be scoped to a namespace - the value of this field forthose objects will be empty.Must be a DNS_LABEL.Cannot be updated.More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces+optional</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? Namespace { get; set; }
#nullable restore
#else
        public string Namespace { get; set; }
#endif
        /// <summary>The ownerReferences property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<global::ArgoCD.Sdk.Models.V1OwnerReference>? OwnerReferences { get; set; }
#nullable restore
#else
        public List<global::ArgoCD.Sdk.Models.V1OwnerReference> OwnerReferences { get; set; }
#endif
        /// <summary>An opaque value that represents the internal version of this object that canbe used by clients to determine when objects have changed. May be used for optimisticconcurrency, change detection, and the watch operation on a resource or set of resources.Clients must treat these values as opaque and passed unmodified back to the server.They may only be valid for a particular resource or set of resources.Populated by the system.Read-only.Value must be treated as opaque by clients and .More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency+optional</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? ResourceVersion { get; set; }
#nullable restore
#else
        public string ResourceVersion { get; set; }
#endif
        /// <summary>The selfLink property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? SelfLink { get; set; }
#nullable restore
#else
        public string SelfLink { get; set; }
#endif
        /// <summary>UID is the unique in time and space value for this object. It is typically generated bythe server on successful creation of a resource and is not allowed to change on PUToperations.Populated by the system.Read-only.More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids+optional</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? Uid { get; set; }
#nullable restore
#else
        public string Uid { get; set; }
#endif
        /// <summary>
        /// Instantiates a new <see cref="global::ArgoCD.Sdk.Models.V1ObjectMeta"/> and sets the default values.
        /// </summary>
        public V1ObjectMeta()
        {
            AdditionalData = new Dictionary<string, object>();
        }
        /// <summary>
        /// Creates a new instance of the appropriate class based on discriminator value
        /// </summary>
        /// <returns>A <see cref="global::ArgoCD.Sdk.Models.V1ObjectMeta"/></returns>
        /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
        public static global::ArgoCD.Sdk.Models.V1ObjectMeta CreateFromDiscriminatorValue(IParseNode parseNode)
        {
            _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
            return new global::ArgoCD.Sdk.Models.V1ObjectMeta();
        }
        /// <summary>
        /// The deserialization information for the current model
        /// </summary>
        /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
        public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
        {
            return new Dictionary<string, Action<IParseNode>>
            {
                { "annotations", n => { Annotations = n.GetObjectValue<global::ArgoCD.Sdk.Models.V1ObjectMeta_annotations>(global::ArgoCD.Sdk.Models.V1ObjectMeta_annotations.CreateFromDiscriminatorValue); } },
                { "creationTimestamp", n => { CreationTimestamp = n.GetDateTimeOffsetValue(); } },
                { "deletionGracePeriodSeconds", n => { DeletionGracePeriodSeconds = n.GetLongValue(); } },
                { "deletionTimestamp", n => { DeletionTimestamp = n.GetDateTimeOffsetValue(); } },
                { "finalizers", n => { Finalizers = n.GetCollectionOfPrimitiveValues<string>()?.AsList(); } },
                { "generateName", n => { GenerateName = n.GetStringValue(); } },
                { "generation", n => { Generation = n.GetLongValue(); } },
                { "labels", n => { Labels = n.GetObjectValue<global::ArgoCD.Sdk.Models.V1ObjectMeta_labels>(global::ArgoCD.Sdk.Models.V1ObjectMeta_labels.CreateFromDiscriminatorValue); } },
                { "managedFields", n => { ManagedFields = n.GetCollectionOfObjectValues<global::ArgoCD.Sdk.Models.V1ManagedFieldsEntry>(global::ArgoCD.Sdk.Models.V1ManagedFieldsEntry.CreateFromDiscriminatorValue)?.AsList(); } },
                { "name", n => { Name = n.GetStringValue(); } },
                { "namespace", n => { Namespace = n.GetStringValue(); } },
                { "ownerReferences", n => { OwnerReferences = n.GetCollectionOfObjectValues<global::ArgoCD.Sdk.Models.V1OwnerReference>(global::ArgoCD.Sdk.Models.V1OwnerReference.CreateFromDiscriminatorValue)?.AsList(); } },
                { "resourceVersion", n => { ResourceVersion = n.GetStringValue(); } },
                { "selfLink", n => { SelfLink = n.GetStringValue(); } },
                { "uid", n => { Uid = n.GetStringValue(); } },
            };
        }
        /// <summary>
        /// Serializes information the current object
        /// </summary>
        /// <param name="writer">Serialization writer to use to serialize this model</param>
        public virtual void Serialize(ISerializationWriter writer)
        {
            _ = writer ?? throw new ArgumentNullException(nameof(writer));
            writer.WriteObjectValue<global::ArgoCD.Sdk.Models.V1ObjectMeta_annotations>("annotations", Annotations);
            writer.WriteDateTimeOffsetValue("creationTimestamp", CreationTimestamp);
            writer.WriteLongValue("deletionGracePeriodSeconds", DeletionGracePeriodSeconds);
            writer.WriteDateTimeOffsetValue("deletionTimestamp", DeletionTimestamp);
            writer.WriteCollectionOfPrimitiveValues<string>("finalizers", Finalizers);
            writer.WriteStringValue("generateName", GenerateName);
            writer.WriteLongValue("generation", Generation);
            writer.WriteObjectValue<global::ArgoCD.Sdk.Models.V1ObjectMeta_labels>("labels", Labels);
            writer.WriteCollectionOfObjectValues<global::ArgoCD.Sdk.Models.V1ManagedFieldsEntry>("managedFields", ManagedFields);
            writer.WriteStringValue("name", Name);
            writer.WriteStringValue("namespace", Namespace);
            writer.WriteCollectionOfObjectValues<global::ArgoCD.Sdk.Models.V1OwnerReference>("ownerReferences", OwnerReferences);
            writer.WriteStringValue("resourceVersion", ResourceVersion);
            writer.WriteStringValue("selfLink", SelfLink);
            writer.WriteStringValue("uid", Uid);
            writer.WriteAdditionalData(AdditionalData);
        }
    }
}
#pragma warning restore CS0618
