// <auto-generated/>
#pragma warning disable CS0618
using Microsoft.Kiota.Abstractions.Extensions;
using Microsoft.Kiota.Abstractions.Serialization;
using System.Collections.Generic;
using System.IO;
using System;
namespace ArgoCD.Sdk.Models
{
    /// <summary>
    /// Event is a report of an event somewhere in the cluster.  Eventshave a limited retention time and triggers and messages may evolvewith time.  Event consumers should not rely on the timing of an eventwith a given Reason reflecting a consistent underlying trigger, or thecontinued existence of events with that Reason.  Events should betreated as informative, best-effort, supplemental data.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
    public partial class V1Event : IAdditionalDataHolder, IParsable
    {
        /// <summary>The action property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? Action { get; set; }
#nullable restore
#else
        public string Action { get; set; }
#endif
        /// <summary>Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.</summary>
        public IDictionary<string, object> AdditionalData { get; set; }
        /// <summary>The count property</summary>
        public int? Count { get; set; }
        /// <summary>MicroTime is version of Time with microsecond level precision.+protobuf.options.marshal=false+protobuf.as=Timestamp+protobuf.options.(gogoproto.goproto_stringer)=false</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::ArgoCD.Sdk.Models.V1MicroTime? EventTime { get; set; }
#nullable restore
#else
        public global::ArgoCD.Sdk.Models.V1MicroTime EventTime { get; set; }
#endif
        /// <summary>Time is a wrapper around time.Time which supports correctmarshaling to YAML and JSON.  Wrappers are provided for manyof the factory methods that the time package offers.+protobuf.options.marshal=false+protobuf.as=Timestamp+protobuf.options.(gogoproto.goproto_stringer)=false</summary>
        public DateTimeOffset? FirstTimestamp { get; set; }
        /// <summary>ObjectReference contains enough information to let you inspect or modify the referred object.---New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs. 1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage. 2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular    restrictions like, &quot;must refer only to types A and B&quot; or &quot;UID not honored&quot; or &quot;name must be restricted&quot;.    Those cannot be well described when embedded. 3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen. 4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity    during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple    and the version of the actual struct is irrelevant. 5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type    will affect numerous schemas.  Don&apos;t make new APIs embed an underspecified API type they do not control.Instead of using this type, create a locally provided and used type that is well-focused on your reference.For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .+k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object+structType=atomic</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::ArgoCD.Sdk.Models.V1ObjectReference? InvolvedObject { get; set; }
#nullable restore
#else
        public global::ArgoCD.Sdk.Models.V1ObjectReference InvolvedObject { get; set; }
#endif
        /// <summary>Time is a wrapper around time.Time which supports correctmarshaling to YAML and JSON.  Wrappers are provided for manyof the factory methods that the time package offers.+protobuf.options.marshal=false+protobuf.as=Timestamp+protobuf.options.(gogoproto.goproto_stringer)=false</summary>
        public DateTimeOffset? LastTimestamp { get; set; }
        /// <summary>The message property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? Message { get; set; }
#nullable restore
#else
        public string Message { get; set; }
#endif
        /// <summary>ObjectMeta is metadata that all persisted resources must have, which includes all objectsusers must create.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::ArgoCD.Sdk.Models.V1ObjectMeta? Metadata { get; set; }
#nullable restore
#else
        public global::ArgoCD.Sdk.Models.V1ObjectMeta Metadata { get; set; }
#endif
        /// <summary>The reason property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? Reason { get; set; }
#nullable restore
#else
        public string Reason { get; set; }
#endif
        /// <summary>ObjectReference contains enough information to let you inspect or modify the referred object.---New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs. 1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage. 2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular    restrictions like, &quot;must refer only to types A and B&quot; or &quot;UID not honored&quot; or &quot;name must be restricted&quot;.    Those cannot be well described when embedded. 3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen. 4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity    during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple    and the version of the actual struct is irrelevant. 5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type    will affect numerous schemas.  Don&apos;t make new APIs embed an underspecified API type they do not control.Instead of using this type, create a locally provided and used type that is well-focused on your reference.For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .+k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object+structType=atomic</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::ArgoCD.Sdk.Models.V1ObjectReference? Related { get; set; }
#nullable restore
#else
        public global::ArgoCD.Sdk.Models.V1ObjectReference Related { get; set; }
#endif
        /// <summary>The reportingComponent property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? ReportingComponent { get; set; }
#nullable restore
#else
        public string ReportingComponent { get; set; }
#endif
        /// <summary>The reportingInstance property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? ReportingInstance { get; set; }
#nullable restore
#else
        public string ReportingInstance { get; set; }
#endif
        /// <summary>EventSeries contain information on series of events, i.e. thing that was/is happeningcontinuously for some time.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::ArgoCD.Sdk.Models.V1EventSeries? Series { get; set; }
#nullable restore
#else
        public global::ArgoCD.Sdk.Models.V1EventSeries Series { get; set; }
#endif
        /// <summary>EventSource contains information for an event.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::ArgoCD.Sdk.Models.V1EventSource? Source { get; set; }
#nullable restore
#else
        public global::ArgoCD.Sdk.Models.V1EventSource Source { get; set; }
#endif
        /// <summary>The type property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? Type { get; set; }
#nullable restore
#else
        public string Type { get; set; }
#endif
        /// <summary>
        /// Instantiates a new <see cref="global::ArgoCD.Sdk.Models.V1Event"/> and sets the default values.
        /// </summary>
        public V1Event()
        {
            AdditionalData = new Dictionary<string, object>();
        }
        /// <summary>
        /// Creates a new instance of the appropriate class based on discriminator value
        /// </summary>
        /// <returns>A <see cref="global::ArgoCD.Sdk.Models.V1Event"/></returns>
        /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
        public static global::ArgoCD.Sdk.Models.V1Event CreateFromDiscriminatorValue(IParseNode parseNode)
        {
            _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
            return new global::ArgoCD.Sdk.Models.V1Event();
        }
        /// <summary>
        /// The deserialization information for the current model
        /// </summary>
        /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
        public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
        {
            return new Dictionary<string, Action<IParseNode>>
            {
                { "action", n => { Action = n.GetStringValue(); } },
                { "count", n => { Count = n.GetIntValue(); } },
                { "eventTime", n => { EventTime = n.GetObjectValue<global::ArgoCD.Sdk.Models.V1MicroTime>(global::ArgoCD.Sdk.Models.V1MicroTime.CreateFromDiscriminatorValue); } },
                { "firstTimestamp", n => { FirstTimestamp = n.GetDateTimeOffsetValue(); } },
                { "involvedObject", n => { InvolvedObject = n.GetObjectValue<global::ArgoCD.Sdk.Models.V1ObjectReference>(global::ArgoCD.Sdk.Models.V1ObjectReference.CreateFromDiscriminatorValue); } },
                { "lastTimestamp", n => { LastTimestamp = n.GetDateTimeOffsetValue(); } },
                { "message", n => { Message = n.GetStringValue(); } },
                { "metadata", n => { Metadata = n.GetObjectValue<global::ArgoCD.Sdk.Models.V1ObjectMeta>(global::ArgoCD.Sdk.Models.V1ObjectMeta.CreateFromDiscriminatorValue); } },
                { "reason", n => { Reason = n.GetStringValue(); } },
                { "related", n => { Related = n.GetObjectValue<global::ArgoCD.Sdk.Models.V1ObjectReference>(global::ArgoCD.Sdk.Models.V1ObjectReference.CreateFromDiscriminatorValue); } },
                { "reportingComponent", n => { ReportingComponent = n.GetStringValue(); } },
                { "reportingInstance", n => { ReportingInstance = n.GetStringValue(); } },
                { "series", n => { Series = n.GetObjectValue<global::ArgoCD.Sdk.Models.V1EventSeries>(global::ArgoCD.Sdk.Models.V1EventSeries.CreateFromDiscriminatorValue); } },
                { "source", n => { Source = n.GetObjectValue<global::ArgoCD.Sdk.Models.V1EventSource>(global::ArgoCD.Sdk.Models.V1EventSource.CreateFromDiscriminatorValue); } },
                { "type", n => { Type = n.GetStringValue(); } },
            };
        }
        /// <summary>
        /// Serializes information the current object
        /// </summary>
        /// <param name="writer">Serialization writer to use to serialize this model</param>
        public virtual void Serialize(ISerializationWriter writer)
        {
            _ = writer ?? throw new ArgumentNullException(nameof(writer));
            writer.WriteStringValue("action", Action);
            writer.WriteIntValue("count", Count);
            writer.WriteObjectValue<global::ArgoCD.Sdk.Models.V1MicroTime>("eventTime", EventTime);
            writer.WriteDateTimeOffsetValue("firstTimestamp", FirstTimestamp);
            writer.WriteObjectValue<global::ArgoCD.Sdk.Models.V1ObjectReference>("involvedObject", InvolvedObject);
            writer.WriteDateTimeOffsetValue("lastTimestamp", LastTimestamp);
            writer.WriteStringValue("message", Message);
            writer.WriteObjectValue<global::ArgoCD.Sdk.Models.V1ObjectMeta>("metadata", Metadata);
            writer.WriteStringValue("reason", Reason);
            writer.WriteObjectValue<global::ArgoCD.Sdk.Models.V1ObjectReference>("related", Related);
            writer.WriteStringValue("reportingComponent", ReportingComponent);
            writer.WriteStringValue("reportingInstance", ReportingInstance);
            writer.WriteObjectValue<global::ArgoCD.Sdk.Models.V1EventSeries>("series", Series);
            writer.WriteObjectValue<global::ArgoCD.Sdk.Models.V1EventSource>("source", Source);
            writer.WriteStringValue("type", Type);
            writer.WriteAdditionalData(AdditionalData);
        }
    }
}
#pragma warning restore CS0618
